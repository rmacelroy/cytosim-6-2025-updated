#!/usr/bin/env python3
#
# A script to submit jobs to the SLURM queuing system
#
# F. Nedelec, 10.2007 --- 9.02.2021, 10.01.2022, 14.03.2023
# Adapted to SLURM at Cambridge on 29.01.2021, 24.11.2024

"""
    Submit an array of jobs to the SLURM system, to be handled by 'go_sim.py'
    
Syntax:
    
    submit.py ARG [mem=????] [queue=????] [hours=INT] [days=INT] [cpu=INT] file1 [file2] [file3] [...]
    
    ARG is passed as arguments to 'go_sim.py' (please check go_sim.py help),
    and you must use quotes if you have multiple arguments to group them together.
    
    Unless specified otherwise, the queue is 'sapphire'.
    The amount of requested memory (default=2G) should be specified in MB:
       mem=1024 (for 1 GB)
       mem=512  (for 512 MB)
       ...
    
Examples:
    
    1. submit.py sim config.cym
       Submit one job to run the config file provided
    
    2. submit.py sim config1.cym config2.cym config3.cym ...
       Submit one job for each config file provided. They will run in parallel.

    3. submit.py 'sim preconfig.py' config.cym.tpl
       Submit one job where the config file will be generated by preconfig.py from config.cym.tpl
       The executable will run sequentially on one node, for each file that is generated.
    
    4. submit.py 'sim 10' config.cym
       Submit one job to run the same config file 10 times sequentially on one node.
    
    5. submit.py 'sim 10' config1.cym config2.cym config3.cym ...
       Submit a different job for each config file provided, with 10 repeats of each
    
    
Last updated 14.11.2024
F. Nedelec
"""

# default parameters for submission:
submit  = 'sbatch'
queue   = 'icelake'
account = ''         # Project name

runtime = '12:00:00' # 12 hours
memory  = 4048       # in MB
ncpu    = 1          # nb of threads per job

import sys, os, shutil, subprocess

# output for error messages:
out  = sys.stderr
# name of subdirectory to create (will be set below)
jdir = 'job00'

#-------------------------------------------------------------------------------

def execute(arg):
    """execute given command with subprocess.call()"""
    try:
        val = subprocess.call(arg)
        if val:
            out.write("ERROR: command failed with value %i\n" % val)
            print(arg)
    except OSError:
        out.write("ERROR, command failed: "+' '.join(arg)+"\n")


def make_new_directory(root):
    """Create an empty directory named as 'rootXX' with a 2-digits number XX"""
    cnt = 0
    while cnt < 10000:
        name = root + '%02i' % cnt
        try:
            os.mkdir(name)
            return name
        except OSError:
            cnt += 1
    out.write("Error: directory '%s' could not be created\n" % root)
    return ''


def write_script(filename, arg):
    """create an executable file containing the commands"""
    f = open(filename, 'w')
    f.write("#!/bin/bash\n")
    for s in arg:
        f.write(s+'\n')
    f.close()
    os.chmod(filename, 0o0700)

#------------------------------------------------------------------------

def job_script(path, conf, exe, jarg):
    """return bash script that will run one job"""
    res = [f'cd {path};']
    # change time of script file to indicate activity:
    res.append(f'touch {conf};')
    # actual work: the job will call go_sim.py once:
    res.append(f'python3 go_sim.py exe="{exe}" {jarg} {conf};')
    # cleanup: move config file into subdirectory 'done'
    res.append(f'mv {conf} {jdir}/done/.;')
    # cleanup: move itself into subdirectory 'done'
    res.append(f'mv $0 {jdir}/done/.;')
    return res


def sub_script(exe):
    """return command that will submit one job"""
    # specify memory, shell, minimum number of cores and queue
    res = [submit, '--nodes=1', '--ntasks=1']
    res.append(f'--cpus-per-task={ncpu}')
    if account:
        res.append(f'--account={account}')
    res.append(f'--job-name={jdir}')
    res.append(f'--partition={queue}')
    res.append(f'--time={runtime}')
    res.append(f'--mem={memory}')
    # define signals sent if time is exceeded:
    res.append('--signal=INT@240')
    res.append('--signal=TERM@10')
    # redirect stderr and sdtout to files:
    res.append(f'--output={jdir}/logs/out')
    res.append(f'--error={jdir}/logs/err')
    # call executable:
    res.append(exe)
    return res


def array_script(jobcnt):
    """return command that will submit a job-array"""
    # define parameters directly in the script:
    res  = ['#SBATCH --nodes=1']
    res.append('#SBATCH --ntasks=1')
    res.append(f'#SBATCH --cpus-per-task={ncpu}')
    if account:
        res.append(f'#SBATCH --account={account}')
    res.append(f'#SBATCH --partition={queue}')
    res.append(f'#SBATCH --time={runtime}')
    res.append(f'#SBATCH --mem={memory}')
    # define signals sent if time is exceeded:
    res.append('#SBATCH --signal=INT@240')
    res.append('#SBATCH --signal=TERM@10')
    # redirect stderr and sdtout to files:
    res.append(f'#SBATCH --output='+jdir+'/logs/%a.out')
    res.append(f'#SBATCH --error='+jdir+'/logs/%a.err')
    # defines the job name and index range:
    res.append(f'#SBATCH --job-name={jdir}')
    res.append(f'#SBATCH --array=1-{jobcnt}')
    res.append('')
    # this will execute 'R????' files in `todo` subdirectory:
    res.append(f'{jdir}/todo/R$SLURM_ARRAY_TASK_ID')
    return res

#-------------------------------------------------------------------------------

def main(args):
    """submit jobs, depending on the arguments provided"""
    global submit, memory, runtime, queue, jdir, ncpu
    
    #find submit command:
    proc = subprocess.Popen(['which', submit], stdout=subprocess.PIPE)
    if proc.wait():
        out.write("Error: submit command `"+submit+"' not found!\n")
    else:
        submit = proc.stdout.readline().strip()
        #print('|'+submit+'|')
    
    # first argument is used for go_sim.py:
    exe = args.pop(0)
    if os.path.isfile(exe):
        exe = os.path.abspath(exe)
    # run executable within the debugger, to get trace if it crashes:
    #exe = 'gdb -batch -ex run -ex bt /home/fjn28/rds/hpc-work/spindle/simd'

    # catch old-style invocation
    if exe.endswith(".cym"):
        print(__doc__)
        sys.exit()
    
    # make new directories for this job
    jdir = make_new_directory('job')
    todo = os.path.join(jdir,'todo')
    os.mkdir(todo)
    os.mkdir(os.path.join(jdir, 'done'))
    os.mkdir(os.path.join(jdir, 'save'))
    os.mkdir(os.path.join(jdir, 'logs'))

    print("    go_sim.py will run `%s' in %s" % (exe, jdir))

    jdup = 1  # number of time each job should be repeated
    jcnt = 0  # number of jobs
    jame = '' # name of file containing job script
    wdir = os.getcwd()
    
    for arg in args:
        if os.path.isfile(arg):
            if os.access(arg, os.X_OK):
                out.write("Error: file `%s' should not be executable\n" % arg)
                sys.exit()
            for x in range(jdup):
                jcnt += 1
                conf = todo + '/config%04i.cym' % jcnt
                shutil.copyfile(arg, conf)
                jame = todo + '/R' + str(jcnt)
                cmd = job_script(wdir, conf, exe, 'name=r%04i'%jcnt+' park='+jdir+'/save')
                write_script(jame, cmd)
        elif arg.isdigit():
            jdup = int(arg)
        else:
            [key, equal, val] = arg.partition('=')
            if key == 'mem' or key == 'memory':
                memory = int(val)
            elif key == 'cpu' or key == 'ncpu':
                ncpu = int(val)
            elif key == 'day' or key == 'days':
                runtime = val+'-00:00:00'
            elif key == 'hour' or key == 'hours':
                runtime = val+':00:00'
            elif key == 'minute' or key == 'minutes':
                runtime = val+':00'
            elif key == 'time':
                runtime = val
            elif key == 'queue':
                queue = val
            elif key == 'account':
                account = val
            else:
                out.write("Error: I do not understand argument `%s'\n" % arg)
                sys.exit()

    if memory < 128:
        out.write("Error: requested memory (%s MB) seems too low\n" % memory)
        sys.exit()

    if ncpu < 1:
        out.write("Error: number of cpu/job must be >= 1\n")
        sys.exit()

    if jcnt < 1:
        out.write("Error: you need to specify at least one config file\n" % arg)
        sys.exit()

    if jcnt > 1:
        print("    submit.py created %i scripts in `%s'" % (jcnt, todo))
        # create script file to run job array:
        job = jdir + '/job.bash';
        cmd = array_script(jcnt)
        write_script(job, cmd)
        # make command to submit this script:
        cmd = (submit, job)
    else:
        cmd = sub_script(jame)
    execute(cmd)


#-------------------------------------------------------------------------------

if __name__ == "__main__":
    if len(sys.argv) < 2 or sys.argv[1].endswith("help"):
        print(__doc__)
    else:
        main(sys.argv[1:])

